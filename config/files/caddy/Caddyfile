# Global settings
{
	# Use ACME staging certificate while testing to not reach
	# certificate issuance attempt rate limit
	# acme_ca https://acme-staging-v02.api.letsencrypt.org/directory

	# Internal logs
	log {
		level DEBUG
	}
}

# * Pihole web UI

pihole.home.arpa {
	reverse_proxy 127.0.0.1:8080
}

# * Copyparty file server

party.home.arpa {
	reverse_proxy unix//run/copyparty/party.sock
}

party.kristofferbalintona.me {
	reverse_proxy unix//run/copyparty/party.sock
	
	# Access logs
	log {
		output file /data/log/copyparty.log {
			roll_size 10MiB
			roll_keep 10
		}
		# More human-readable format
		format console
	}
	log {
		output file /data/log/copyparty-json.log {
			roll_size 30MiB
			roll_keep 10
		}
		# For usage with external log parsers
		format json
	}

	# DNS-01 ACME verification.  See
	# https://caddy.community/t/how-to-use-dns-provider-modules-in-caddy-2/8148
	# for Caddy-specific instructions.
	#
	# NOTE: For this to work, I need a build of Caddy that has the
	# DNS module corresponding to my DNS provider.
	#
	# I use this method of certificate verification because I've
	# configured my firewall to geo-block non-US IPs, so automatic
	# the typical automatic means of verification fail.
	#
	# This domain is registered under Namecheap but I've directed
	# Namecheap to use Netlify's DNS servers (since I host the
	# domain on Netlify), so see the Netlify DNS challenge module
	# for Caddy: https://github.com/caddy-dns/netlify.
	#
	# For Netlify, a personal API token should be used as the
	# personal access token
	tls {
		# Bind mint the access token file and reference the
		# path
		dns netlify {file./run/secrets/netlify-access-token}
	}
}

# * Goaccess web access log analyzer

goaccess.home.arpa {
	root * /var/www/goaccess
	file_server
	reverse_proxy /ws 127.0.0.1:7890
}
