# Global settings
{
	# Use ACME staging certificate while testing to not reach
	# certificate issuance attempt rate limit
	# acme_ca https://acme-staging-v02.api.letsencrypt.org/directory

	# Internal (non-access) logs
	log internal {
		level INFO
		exclude http.log.access
		output file /data/log/caddy-internal-json.log {
			roll_size 10MiB
			roll_keep 4
		}
		format json
	}
	# HTTP access logs
	log access {
		level INFO
		include http.log.access
		output file /data/log/caddy-access-json.log {
			roll_size 10MiB
			roll_keep 10
		}
		format json
	}

	servers {
		# Work well with requests traveling through proxies.
		# The two settings below are recommended from
		# https://github.com/dani-garcia/vaultwarden/wiki/Proxy-examples.
		#
		# Accept forwarded IPs that originate from my
		# Wireguard subnet
		trusted_proxies static 10.0.0.0/24
		# See
		# https://caddyserver.com/docs/caddyfile/options#trusted-proxies-strict
		# for why we enable this setting
		trusted_proxies_strict
		# When a request comes from a trusted proxy, determine
		# the client IP by reading these headers, in this
		# order
		client_ip_headers X-Forwarded-For X-Real-IP
	}

	# Make the coraza_waf block first in the evaluation order
	order coraza_waf first

	# Configure the caddy-security module to use Pocket ID.
	# Pocket ID counts as a "generic" OIDC provider (since it
	# implements OIDC plainly), so we can use this Caddyfile from
	# caddy-security as an example:
	# https://github.com/authcrunch/authcrunch.github.io/blob/main/assets/conf/oauth/generic/Caddyfile
	order authenticate before respond # Require authentication before response
	security {
		oauth identity provider pocket_id {
			delay_start 3
			realm pocket_id
			driver generic
			client_id {file./run/user/1000/secrets/caddy/pocket-id/client-id}
			client_secret {file./run/user/1000/secrets/caddy/pocket-id/client-secret}
			# The scopes of Pocket ID are shown in the
			# OIDC client data preview.  Include all of
			# them.
			#
			# NOTE: Adding the "groups" scope will have
			# the groups added to the "x-token-user-roles"
			# HTTP header, a default claim
			scopes openid email profile groups
			# My Pocket ID subdomain
			base_auth_url https://pocket-id.kristofferbalintona.
			metadata_url https://pocket-id.kristofferbalintona.me/.well-known/openid-configuration
			# See
			# https://github.com/greenpau/caddy-security/issues/389#issuecomment-3059648144
			# for the line below.  Extract all "userinfo"
			# endpoing responses.  Used later in
			# authorization blocks to retrieve all the
			# remaining JWT token fields received by
			# Pocket ID, like so:
			#
			#   inject header "X-Username" from "userinfo|preferred_username"
			#
			# The above gets the "preferred_username"
			# field.  For Pocket ID, the available fields
			# are listed in the "Userinfo" tab in the OIDC
			# client data preview menu.
			extract all from userinfo
		}

		# Authentication is the process in proving a user's
		# identity.  Authorization are the rules for what a
		# given user can access.  We must define at least one
		# block for both.

		authentication portal pocket_id_portal {
			enable identity provider pocket_id
			# 14 days until re-authentication required
			crypto default token lifetime 1209600
			cookie insecure off # HTTPS-only cookies
			cookie samesite none # Pocket ID needs cross-site
			# Declare a cookie for each site I use Pocket
			# ID authentication with.  See
			# https://docs.authcrunch.com/docs/authenticate/auth-cookie
			#cookie domain jellyfin.kristofferbalintona.me

			# Modify metadata (claims)
			transform user {
				match realm pocket_id
				# Add claims (information) to tokens.
				# See
				# https://docs.authcrunch.com/docs/authenticate/user-transforms.
				# Can be injected into HTTP headers or
				# checked against later after
				# authentication (see authorization
				# policies)
				action add role authp/user # Helpful for matching all users in authorization
			}
		}

		# See
		# https://docs.authcrunch.com/docs/authorize/syntax
		# for the syntax and possible directives.  In
		# particular,
		# https://docs.authcrunch.com/docs/authorize/acl-rbac#default-allow-acl
		# is useful for knowing the ways to allow or deny
		# access in authorization policies
		authorization policy pocket_id_policy_user {
			## Tokens
			# Most secure setting: only trust cached
			# tokens (cookies).  "header" can be injected;
			# "query" can be leaked via URLs
			set token sources cookie
			# Validate the found JWT token first
			validate bearer header

			# Subdomain path matching the callback URL of
			# the corresponding Pocket ID OIDC client's
			# (excluding the "authorization-code-callback"
			# suffix).  See also
			# https://docs.authcrunch.com/docs/authorize/auto-redirect-url
			set auth url /oauth2/pocket_id

			# Allow everyone
			allow roles authp/user

			## Add headers to every authorized packet
			inject headers with claims # Default headers
			# Custom Pocket ID headers.  See
			# https://docs.authcrunch.com/docs/authorize/headers#auto-defined-headers
			# for the syntax of injecting them.  For a
			# list of available Pocket ID fields, see the
			# comment above regarding "extract all from
			# userinfo".
			inject header "X-Token-Preferred_Username" from "userinfo|preferred_username"
		}
	}

	# Integration with CrowdSec via (caddy-crowdsec)
	crowdsec {
		# See https://caddyserver.com/docs/modules/crowdsec
		# for a description of the possible settings

		# LAPI host + port.  Caddy is run on the host network,
		# and CrowdSec in a container network with this port
		# published (to the host)
		api_url http://127.0.0.1:7200
		# API key given after registering this bouncer with
		# e.g. "podman exec crowdsec cscli bouncers add
		# caddy-bouncer"
		api_key {file./run/user/1000/secrets/caddy/crowdsec-bouncer/api-key}
		# How often to sync decisions with the LAPI
		ticker_interval 15s
	}
	# Ensure the bouncer runs at an effective time.
	# Alternatively, the crowdsec directive can be e.g. placed
	# inside a route block to express the order explicitly
	order crowdsec first
}

# ** Snippets

# *** Log files

(service-logs) {
	log {
		output file /data/log/{args[0]}-console.log {
			roll_size 10MiB
			roll_keep 10
		}
		# More human-readable format
		format console
	}

	log {
		output file /data/log/{args[0]}-json.log {
			roll_size 30MiB
			roll_keep 10
		}
		# More human-readable format
		format json
	}
}

# *** HTTP headers
# These are settings for the sake of hardening.  Most of them were
# taken from https://turbocloud.dev/book/web-application-firewall/ and
# https://github.com/dani-garcia/vaultwarden/wiki/Proxy-examples.

(headers_security_global) {
	header {
		# Prevent clickjacking
		#
		# NOTE 2026-01-10: SAMEORIGIN is preferable to DENY
		# (outright rejection) because Pocket ID authorization
		# sometimes (always?) relies on same-site frames.
		X-Frame-Options "SAMEORIGIN"
		# Prevent MIME type sniffing
		X-Content-Type-Options "nosniff"
		# Referrer policy: don't show full URLs when referred
		# to another side
		Referrer-Policy "strict-origin-when-cross-origin"
		# Cross-site scriptin (XSS) protection
		X-XSS-Protection "1; mode=block"
		# Remove server name
		-Server
		# Remove X-Powered-By though this shouldn't be an
		# issue, but better safe than sorry
		-X-Powered-By
	}
}

(headers_security_public) {
	header {
		# Strict Transport Security (HSTS); makes HTTPS
		# mandatory over HTTP.  (Note: Assumes that HTTPS and
		# TLS is working properly.  Will get in the way if TLS
		# isn't working, e.g., during testing)
		Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
	}
}

(headers_security_private) {
	header {
		# Prevent search engines from indexing.  Should be
		# used for private domains that should not be indexed
		X-Robots-Tag "noindex, nofollow"
	}
}

# *** TLS

# DNS-01 ACME verification.  See
# https://caddy.community/t/how-to-use-dns-provider-modules-in-caddy-2/8148
# for Caddy-specific instructions.
#
# NOTE: For this to work, I need a build of Caddy that has the DNS
# module corresponding to my DNS provider.
#
# I use this method of certificate verification because I've
# configured my firewall to geo-block non-US IPs, so automatic the
# typical automatic means of verification fail.
#
# This domain is registered under Namecheap but I've directed
# Namecheap to use Netlify's DNS servers (since I host the domain on
# Netlify), so see the Netlify DNS challenge module for Caddy:
# https://github.com/caddy-dns/netlify.
#
# For Netlify, a personal API token should be used as the personal
# access token
(tls_dns_netlify) {
	tls {
		# Bind mint the access token file and reference the
		# path
		dns netlify {file./run/user/1000/secrets/caddy/netlify-access-token}
	}
}

# *** Coraza (WAF)

# See also the order directives in the global settings

(coraza) {
	coraza_waf {
		load_owasp_crs
		directives `
		# See
		# https://github.com/corazawaf/coraza/blob/main/coraza.conf-recommended
		Include @coraza.conf-recommended
		# See
		# https://github.com/corazawaf/coraza-coreruleset/blob/main/rules/%40crs-setup.conf.example
		Include @crs-setup.conf.example
		Include @owasp_crs/*.conf

		SecDefaultAction "phase:3,log,auditlog,pass"
		SecDefaultAction "phase:4,log,auditlog,pass"
		SecDefaultAction "phase:5,log,auditlog,pass"
		SecRuleEngine On

		SecAuditEngine RelevantOnly
		SecAuditLog /data/log/coraza-audit.log
		SecAuditLogFormat json

		SecDebugLog /data/log/coraza-debug.log
		SecDebugLogLevel 3
		`
	}
}

# *** MaxMind geo-blocking
# I use the caddy-maxmind-geolocation module for geoblocking.  To test
# whether geoblocking is working, use something like
# https://check-host.net/check-http

(maxmind-us-il) {
	# Since we'll be passing this to error/respond for blocking,
	# it should match all IPs that should be blocked
	@geo_blocked {
		not remote_ip private_ranges
		not maxmind_geolocation {
			# See where the geolite2-country-mmdb and
			# geolite2-city-mmdb packages install the
			# databases.  The city database is a superset
			# of the country database
			db_path /var/lib/geoip/GeoLite2-City.mmdb
			allow_countries US
			allow_subdivisions IL
		}
	}
}

# *** Subdomain policies

(policy_global) {
	import tls_dns_netlify
	import headers_security_global
}

# Policy for domains exposed only locally (via my local DNS)
(policy_public) {
	import policy_global
	import headers_security_public

	import maxmind-us-il
	error @geo_blocked 403

	# CrowdSec bouncer (caddy-crowdsec): block if CrowdSec deems
	# the client malicious
	crowdsec
}

# Policy for all domains exposed to the internet
(policy_private) {
	import policy_global
	import headers_security_private

	# Only access in local networks
	@external not remote_ip private_ranges
	error @external 403
}

# * Domains

# ** Pihole web UI

pihole.home.kristofferbalintona.me {
	reverse_proxy 127.0.0.1:7080
	import policy_private
}

# ** Copyparty file server

(copyparty_socket) {
	reverse_proxy unix//run/user/1000/copyparty/copyparty.sock
}

party.home.kristofferbalintona.me {
	import copyparty_socket
	import policy_private
}

party.kristofferbalintona.me {
	import copyparty_socket
	import policy_public
	import service-logs copyparty
}

# ** Goaccess web access log analyzer

goaccess.home.kristofferbalintona.me {
	root * /var/www/goaccess
	file_server
	reverse_proxy /ws 127.0.0.1:7890
	import policy_private
}

# ** Vaultwarden
# See also
# https://github.com/dani-garcia/vaultwarden/wiki/Proxy-examples for
# using Vaultwarden specifically with Caddy

vault.home.kristofferbalintona.me {
	reverse_proxy 127.0.0.1:7000
	import policy_private
	import service-logs vaultwarden
	# Only access admin page in local networks.  policy_private
	# should only make this domain reachable only locally, but to
	# avoid future misconfigurations I include it anyway
	@admin {
		path /admin*
		not remote_ip private_ranges
	}
	error @admin 403
}

# ** Gatus

gatus.home.kristofferbalintona.me {
	reverse_proxy 127.0.0.1:7090
	import policy_private
}

# ** Pocket ID

pocket-id.kristofferbalintona.me {
	reverse_proxy unix//run/user/1000/pocket-id/pocket-id.sock
	import policy_public
	import service-logs pocket-id
}

# ** Transmission

transmission.home.kristofferbalintona.me {
	reverse_proxy 127.0.0.1:9091
	import policy_private
}

# ** qBittorrent

qbittorrent.home.kristofferbalintona.me {
	reverse_proxy 127.0.0.1:6701
	import policy_private
}

# ** Prowlarr

prowlarr.home.kristofferbalintona.me {
	reverse_proxy 127.0.0.1:13031
	import policy_private
}

# ** Sonarr

sonarr.home.kristofferbalintona.me {
	reverse_proxy 127.0.0.1:15151
	import policy_private
}

# ** Radarr

radarr.home.kristofferbalintona.me {
	reverse_proxy 127.0.0.1:14100
	import policy_private
}

# ** Jellyfin

jellyfin.kristofferbalintona.me {
	reverse_proxy 127.0.0.1:17200
	import policy_public
}

# ** Bazarr

bazarr.home.kristofferbalintona.me {
	reverse_proxy 127.0.0.1:9799
	import policy_public
}
